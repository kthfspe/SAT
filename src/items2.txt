b"# System Architecture2\n\nIT IS HIGHLY RECOMMENDED TO GIVE THE FOLLOWING README A THOROUGH READING BEFORE ARCHITECTING AND USING THE DRAWIO INTERFACE TO DEVELOP THE ARCHITECTURE DESIGN. :)\n\nA system is any entity that is of interest. In this context, the brakes of the formula student car could be considered as a system. A system can be broken down into its system elements. Moreover, the car itself is a system composed of smaller inter-related systems, making it a system of systems. System architecture then refers to the conceptual model that can be used to correctly understand and define different aspects of the system, for example, operational modes, behaviour, physical composition etc. These aspects are called views and it is common to use multiple views to completely express all aspects of a system. A well- defined system architecture will provide consistent information across different views. One of the key functions of the system architecture is to define interfaces between system elements.\n\n![Multiple views for the same system](https://i.ibb.co/7G3Gpmt/image.png)\n\nThe scope of system architecture here is limited to the electrical system of a formula student car. The electrical system of the formula student car can be defined as any part of the car that needs electrical energy to perform it's task. System architecture development would be one of the first steps in the design phase of the electrical system. It is imperative that most of the systems have to be documented first in the system architecture before its design can begin. This is to ensure that the system is being thought of and optimized as a whole rather than just it's elements. However, it is almost impossible to completely define all aspects of the system initially and therefore there should be room for modifications and changes during the whole development process. In this case, it would be important to be consistent with all interfaces since that brings more modularity in the system and enabling late changes. Interfaces in an electrical system can be modeled as different signals, for example, CAN, Analog, Digital etc.\n\nThe 2 most basic views of a system are the physical and functional architecture and the scope will be limited to these two for a formula student car. They are explored in the following sections. In the future, the views can be extended to behavioural architecture, where the operational modes of each functionality is defined. Another aspect that can be integrated is the relation of architectural artifacts to requirements, use cases and scenarios. However, since the value that it provides compared to the effort for implementation is low, it is omitted for now.\n\nThe system architecture provides the inputs for system design. It is very common in the formula student context to mix the two up. For example, how the electrical circuit should look like is beyond the system architecture's scope. However, the architecture should make the interfaces of different functional and physical models clear. \n\n\n## Product Hierarchy\nThe product hierarchy is more of a visual tool aimed at other members of the team to get a bird's eye view of the system. This is quite intuitive as well as it is ordered by physical components. However, there should be a possibility to order it from the functional view as well.\n\nIt shows the relation between each component and how they are related. For example, a component can have the parent as the chassis, which would mean that they are directly mounted on the chassis. Or it could have an enclosure as a parent. After compiling all the information in the architecture mechanical designers can easily view what components are present from the electrical system and which enclosure do each component have to be placed in. This can help them design the mechanical concept with these requirements in mind, saving a lot of time spent usually on integration of different systems into the car.\n\nThe information model by which the product hierarchy is built on is shown below:\n![Product Tree](https://i.ibb.co/3mxxtTy/Product-Tree.jpg)\n\n## Typical Way of Working\nHaving a car and system currently working does not mean that it is working in an optimum way. Hence it is important to start with a clean slate and to go over the steps of architecture design when thinking about a new car. The first step would be to list out all functions of the electrical system and then to filter out the ones that would involve the electrical system in any way. Each of these functions can be split in an number of ways. These functions have to be divided into function elements and all the inputs and output of the functions have to be determined at this stage. For example, 'Braking the car' would be a function and it could then be split into a sensing element, computation element, braking element. It is highly rewarding to keep this functional breakdown independent of technology or type of implementation because this enables us to choose the best way to do our function rather then the functionality limiting our options. Function partitioning is an art and it takes some practice to do it in a good way. The next step is then to define interfaces for these functional elements. It could be signals, information flow of some kind or dependencies. Once a functional breakdown of the functionality and the system is obtained, then it is time to evaluate how these functional elements can be implemented. For example, do we need to make our own sensing element, or do we need to buy a sensor but make control unit to do the computation etc. This step allocates all the functional elements to a hardware counterpart. Linking the functional elements to requirements and corresponding test cases closes the whole engineering design loop. However, in the context of formula student where the main source of the requirements in the competition rulebook and handbook and the timeline from design to competition is really short, it is not addressed here. Having a clear architecture definitely eases the process of testing the system categorically and makes it easier to hand out work tasks to team members with clear definitions.\n\n\n## Functional Architecture\nA functional architecture is a set of functions and sub-functions that defines the transformations performed by the system to complete its mission. So from an architect's point of view it is crucial to break down all the significant goals of the formula student car into functions. For example: Braking Function, Brake System Plausibility Check, Propulsion Function etc. Functionality itself is an abstract term and the goal here is to capture a somewhat clear picture of how each functionality is broken down into modules and how they interact with each other to perform required functionality. \n\nA common question when breaking down functions is to what detail should it be broken down into. A good rule of thumb is it should be broken down to a level where the element is independent unit, all the inputs and outputs can be clearly defined and the function element is small enough to be carried out by one type of implementation. For example, a function element that does both computation and controlling of an output would not be detailed enough. In such cases, there is still room for simplification. One of the outcomes of this process is that it will become clear which function elements are reused the most in the vehicle (Ex: 24V to 5V converter, an obvious one.) and they can be made as standardized designs. This helps change the focus of designers from repetitive tasks to more challenging and novel ones. Another out\n\n\n### Functional Architecture Library\n\nThis section explains the meaning and usage of all blocks and signals that are to be used when drawing out the functional architecture of the system.\n\n#### Blocks\n1. FE - Function Element\nThis block is the core of the functionality. Any part of the functionality that is not an input or output to the environment is categorized as a function element. Some examples of what a function element can do are: Monitor, Manager, Checker, Supervisor, Controller, Module, Warning, Coordinator, Activations, Detection. it is a very general and abstract block that can end up being a circuit or a piece of code etc. Multiple instances is not allowed for function elements as it reduces the scope of function elements which forces the architect to break it down to more reasonable detail.\n\t##### Attributes\n\t- Name: This field should be unique to a function element. Component naming guidelines applies here.\n\t- Function: This is the functional parent that it is assigned to. In order to view all the elements that a function is composed of, it is necessary to have the same function name in all the blocks performing parts of it. This field cannot be left empty.\n\t- Allocation: This field specifies the physical allocation of that particular function element. The value of this attribute should be a name of a block in the physical architecture. \n\t- Implementation: This value is a reflection on the design decision for this particular function element. It also forces the architect to break a functionality down enough so that each function element fits into only one type of implementation. Examples: Code, Electrical circuit, Discrete electrical component. \n\n2. ENVIN - Environmental Inputs\nThis block is meant for any interfaces that you would need from the environment to the system of interest. In the context of a formula student car it could mean the driver, ESO, ASR, physical inputs.\n\t##### Attributes\n\t- Name: This field should be unique to an environmental input. Component naming guidelines applies here.\n\t- Function: This is the functional parent that it is assigned to. In order to view all the elements that a function is composed of, it is necessary to have the same function name in all the blocks performing parts of it. This field cannot be left empty.\n\t- Allocation: This field specifies the physical allocation of that particular block. The value of this attribute should be a name of a block in the physical architecture.\n\t- Implementation: This value is a reflection on the design decision for this particular element. It also forces the architect to break a functionality down enough so that it fits into only one type of implementation. Examples: Sensor, Switch, Pushbutton etc.\n3. ENVOUT - Environmental Outputs\nThis block is meant for any interfaces of the system to the outside world. It could be in the form of a light, sound, display etc.\n\t##### Attributes\n\t- Name: This field should be unique to an environmental output. Component naming guidelines applies here.\n\t- Function: This is the functional parent that it is assigned to. In order to view all the elements that a function is composed of, it is necessary to have the same function name in all the blocks performing parts of it. This field cannot be left empty.\n\t- Allocation: This field specifies the physical allocation of that particular block. The value of this attribute should be a name of a block in the physical architecture. \n\t- Implementation: This value is a reflection on the design decision for this particular element. It also forces the architect to break a functionality down enough so that it fits into only one type of implementation. Examples: LED Light, Sound Buzzer, LCD Display etc.\n\n#### Signals\n4. CAN - CAN Message\nThis is a signal meant to send information between 2 CAN nodes. Any node that has a CAN message as a source or a destination will automatically be a CAN node in the generated documents. Multiple instances of CAN messages are allowed, however conflicting signal definitions are not. For example, in all instances of a CAN message signal1 can be assigned to one and only one SignalName. CAN Message information from all instances will be compiled for documentation.\n\t##### Attributes\n\t- Name: This is the name of the CAN Message. Its good to keep in mind that each message can contain multiple signal. The signal naming guidelines applies here.\n\t- MessageID: This is a unique ID for the message and should be filled in as decimal. The vlaue should be in the range of 0 - 2047 both included.\n\t- BusSegment: The system can have multiple CAN buses and it has to be specified which bus is used for each message. Any node that has a message in a particular bus segment will automatically be assigned as a CAN node in that segment.\n\t- CycleTime_ms: This value specifies how often this message needs to be send. It this value is not filled in then it will be considered as an arbitrary message and not a periodic one.\n\t- Length: Length of data. Value should be between 1-8 both included.\n\t- Multiplexed: Yes or No field. It specifies if the message is multiplexed for different components in the CAN bus using the same message structure\n\t- NoOfSignals: The number of signals within this CAN message. This has the match in all CAN message instances in the architecture.\n\t- Signal1, Signal2 ... SignalN: These fields are used to specify the names of the signal and the size of it separated by an underscore. For example, Signal1: BrakePressure_5 Would mean the name of the signal is BrakePressure and is of 5 bit length and Signal1 by default starts at bit 0. If these fileds are left empty, then it would be treated as no signals, unless there is another instance that has corresponding signal names.\n\n\n5. ANA - Analog Signal\nThis signal is used for any signal that cannot be categorized into fixed steps. Any signal that has a continuous range. This signal can also have multiple instances as long as its name is reused.\n\t##### Attributes\n\t- Name: The signal naming guide applies here. \n\t- VoltageMin: The minimum voltage that is relevant to its operation. DefaultValue: 0V\n\t- VoltageMax: The maximum voltage that is relevant to its operation. DefaultValue: 24V\n\t- Unit: This field specifies the unit of the min and max values. Accepted values are V and mV.\n\n\n6. DIG - Digital Signal\nThis is used for any signal that has fixed voltage states or follows a standard/known protocol such as I2C, SPI etc. This signal can also have multiple instances where its name acts as the unique identifier.\n\t##### Attributes\n\t- Name: The signal naming guide applies here.\n\t- VoltageHigh: This should be the voltage level that is nominally considered as a boolean 1. DefaultValue: 0V\n\t- VoltageLow: This should be the voltage level that is nominally considered as a boolean 0. DefaultValue: 0V\n\t- Protocol: If the signal follows a protocol for example I2C, SPI, Ethernet, USB etc. should be specified here. If it is only a bare bone digital signal then its logic level can be specified here, for example TTL. If it does not folllow any protocol, the value should be 'NA'.\n\t- ProtocolSegment: This field is used to specify the segment of the protocol that is being used. This can be left empty if there is only one segment associated with its physical allocation. For example, if a PCB has 2 SPI interfaces, then the choice of interface for the signal must be specified here.\n\t- NoOfWires: All the above protocol can comprise of different number of wires and that needs to be specified here. DefaultValue: 1\n\n7. IV - Internal Variable\nThis signal can be used whenever its not an electrical signal that is being sent between function elements.This signal can also have multiple instances where its name acts as the unique identifier.\n\t##### Attributes\n\t- Name: The signal naming guide applies here.\n\t- DataType: If this a variable within code, it would be the data type used. For example, int, float, long etc. \n\t- Implementation: This field distinguishes the signal based on its design choice of implementation. Examples: FunctionArguments, FunctionReturnType, ROS Service etc.\n\t- Unit: The unit of the quantity being communicated.\n\t- Periodic/Event: Periodic would be if this variable is sent periodically. Event would be when it is sent only if some precondition/trigger is met. If the signal is only sent at arbitrary times it would be categorized as Event. The value can also be filled in as 'P' and 'E' instead of the whole words being used.\n\n8. PUBSUB - Publisher/Subscriber\nThis signal can be used if there exist a publisher and subscriber relationship between function elements. If the arrow is from block 1 to block 2. It would mean the block 1 publishes to a topic that is read by block 2. This, in a way forces not to have topics that are not being read by any element. This signal can also have multiple instances where its name acts as the unique identifier.\n\t##### Attributes\n\t- Name: The name of the signal itself that is being transferred. For example: Lidar_RAW.\n\t- Topic: The topic name that will be used for facilitating this communication. In most cases this is the same as the Name of the signal. If this field is left empty, then the name of the signal would be assigned as the name of the topic.\n\t- DataType: The data type that is used in this relationship. This could be composite datatypes like struct, class etc. as well.\n\t- Implementation: This field distinguishes the signal based on its design choice of implementation. Examples: ROS, MQTT, DDS.\n\t- Unit: The unit of the quantity being communicated.\n\t- Periodic/Event: Periodic would be if this variable is sent periodically. Event would be when it is sent only if some precondition trigger is met. If the signal is only sent at arbitrary times it would be categorized as Event. The value can also be filled in as 'P' and 'E' instead of the whole words being used.\n\n## Physical Architecture\nThe physical architecture aims to show the system as a arrangement of many physical elements along with its interfaces. This view is much more intuitive than functional architecture. It involves breaking down the functionality into physcial components and also allocating the function elements from the functional architecture to each component.\n\nAn integral part of automotive EE systems are its wiring harness. In this case, the information in the physical architecture about components and interfaces combined with a physical lookup can generate a basic wiring guide. Although it might not be accurate to the final dimension of the wiring harness, it will give an idea to the system architects about how the layout would look like even before the season has begun. This is a great advantage and outcome of using a single model to express the system and to do it early in the development phase.\n\n### Physical Architecture Library\n\nThis section explains the meaning and usage of all blocks and signals that are to be used when drawing out the functional architecture of the system. As there are many repetitive attributes among these blocks, they will be dealt with together.\n#### Blocks\n\n1. PCU - Programmable Control Unit\nThis block is used for any PCB designed in-house that contains a micro-controller circuit or has any programmable features to it. \n\n2. NCU - Non-programmable Control Unit\nThis block is used for any PCB designed in-house that does not contain any programmable feature to it. Discrete electrical components will also fit into this category.\n\n3. HMI - Human Machine Interface\nThis block is used for any off-the-shelf component that has any kind of interface to a human (driver, ESO, ASR etc.) Example: Indicator lights, Sound buzzer, Switches, RTD Button etc.\n\t##### Specific Attributes\n\t- Type: This is an attribute to specify the component type. For example: Display, DriverIndicator, VehicleIndicator, LED, Buzzer, ToggleSwitch, RotaryKnob, Pushbutton etc.\n\t- Colour: Colour of the button or the indicator etc. Example: RED, YELLOW, BLUE etc.\n\n4. SENS - Sensor\nThis block is used for any off-the-shelf component that is a sensor on the vehicle. Example: Wheelspeed sensor, LIDAR, GPS etc.\n\t##### Specific Attributes\n\t- OutputType: The type of output form the sensor. Example: Voltage, Current, SPI, CAN etc.\n\t- OutputMin: Applicable to discrete output types only like analog, digital etc. \n\t- OutputMax: Applicable to discrete output types only like analog, digital etc.\n\t- OutputParameter: The physical quantity that is being measured. For example: Position, Speed, Voltage etc.\n\n5. ACT - actuator\nThis block is used for any off-the-shelf component that is an actuator of some kind. Example: Steering actuator, Propulsion Motors etc.\n\t##### Specific Attributes\n\t- ActuatorType: Example: BLDC, 3 Phase Induction Motor etc.\n\n6. OTSC - Off The Shelf Hardware\nThis block is used for any off-the-shelf component that does not fit into the categories of HMI, SENS or ACT. For example: dSpace MicroAutoBox, VESC Motor Controller, Nvidia Xavier.\n\n7. MCON , FCON - Male and Female Connector\nThese blocks will be used for connectors. NOTE: Only the connectors on the component side needs to be drawn in the architecture. The gender mirrored information for the wiring will be automatically generated.\n\t##### Specific Attributes\n\t- Name: Guidelines for naming connectors applies here.\n\t- Type: Type fo connector. Example: W2B, B2B, W2W for Wire to Board, Board to board and Wire to wire respectively.\n\t- NoOfPins: Total number of pins available in the connector. Not every pin has to be in use.\n\t- Pin1, Pin2 ... PinN: The name of the signal routed through each pin. If it is left empty, it will be treated as 'NotConnected'. If the pin is not connected, it is recommended to fill in 'NC'.\n\t- VoltageRating: The maximum voltage rating allowed by the datasheet of the connector\n\t- CurrentRating: The maximum current rating allowed by the datasheet of the connector\n\t- Placement: The filed can be used to further specify the position. For example: Where in an enclosure is a particular connector place on. Or where in a PCB is the connector mounted.\n\n8. BAT - Battery\nThis block will be used for any power sources within the system. Example: LV Battery, HV Battery(sub stacks level) etc.\n\t- Voltage: The nominal voltage output of the battery.\n\t- MinVoltage: The voltage at which it is considered to be discharged.\n\t- Configuration: This has to be in the format MsNp, which would mean M cells in series and N in parallel.\n\t- Capacity: The rated capacity of the battery in Ah.\n\t- SourceFuseRating: The rating of the fuse that is within the battery. It could also be the trip current of the battery.\n\n\t#### Common Attributes Among Physical Architecture Blocks\n\t- Name: For all the blocks, the name field will act as its unique identifier when there are multiple instances. Component naming guidelines applies here.\n\t- Parent: This specified which component is it a part of in the product hierarchy. The value here should be a another block existing in the physical architecture or it should read 'CAR' if the component is directly mounted on the chassis. If this field is left empty, it will be treated as its directly mounted on the chassis.\n\t- Position: This is an identifier tag that is used to denote the actual position of the car. The tag would then translate to an (x,y,z) coordinate in the CAD of the car. The list of identifiers available can be found in the PositionLookUpTable. All the positions will have a prefix such as POS_id.\n\t- Supply: This field specifies the nominal voltage for a component to work. The following are the cases that are possible.\n\t\t1. If source is directly from a battery, the value should be the voltage level of the battery or the name of the battery. For example: 24, would mean that this component is powered directly from the battery. \n\t\t2. If the power supply is from another component and using the same power source as it: The name of the supplier component block should be filled in here. For example: If the field for a brake sensor supply is filled in as VMU. It would mean that it is supplied from VMU from the same power line as VMU is getting its supply from. \n\t\t3. If the power supply is from another component but not using the same power source as the supplier component: The field has to be filled in as SupplyComponent_VoltageLevel. For example: If the brake sensor supply is filled in as VMU_5, then it would mean that it is getting its supply from VMU of a voltage level different from that of what VMU is supplied from and it is at 5V.\n\t- GND: This field specifies the grounding point of the component. The following cases are possible.\n\t\t1. If the GND is directly at the battery source: In this case the field can be the voltage level of the battery or the name of the battery. \n\t\t2. If the GND is at another component: The field should have the name of the component.\n\t\t3. If the GND is a physical grounding point: The field should have a position tag from the PositionLookUpTable. It should have a prefix of POS_id.\n\t- FuseRating: This is the fuse rating applied external to the component in Amps. For example: IF its a PCB directly supplied from the battery, then the rating of the power line in the fuse board should be filled in here. The internal fuse inside a PCB is not of concern to the physical architecture.\n\t- MaxCurrent: The maximum current that is drawn during the operation of a component in Amps.\n\t- NominalCurrent: The current drawn when the component is in normal race situation in Amps.\n\t- MfgPartNumber: The part number specified by the manufacturer of the component. This only applies to off the shelf components and is useful when generating a BOM.\n\n#### Signals\nThe description and attributes for these signals are the same as in functional architecture library.\n\n9. CAN - CAN Message\n10. ANA - Analog Signal\n11. DIG - Digital Signal\n\n#### Config Files\n\n12. Position Lookup:\nThis is a lookup table that specifies ROUTING distances between all possible positions on the car. The table will be an NxN matrix where N is the number of positions available. And each cell i,j would have the routing distance between positions i and j in centimeters. It is highly advisable to not to reuse positions or to change position tags to different (x, y, z) coordinates to avoid confusion over the years.\n\n[comment]: <> (13. Connector Lookup?)\n\n## Rules & Best Practices\n\t\n### General Rules\nMeant to be followed at all times.\n\t1. Multiple instances of the same blocks should have the same name. If the name differs even by one character, they will be treated as different entities.\n\t2. All draw.io files should be saved as uncompressed xml files in github instead of .drawio extenson\n\t3. Specify clearly what has been changed with each commit of the xml files.\n\t4. All signals drawn from and to a block must snap to the block at a connection point. These points are highlited in green when hovered over the boundary of a block.\n\t5. Unless otherwise mentioned all physical quantities that are filled in as attributes should be in their respective SI units.\n\t6. Physical architecture blocks are only allowed to use signals from the physical architecture library. The same applies for funcitonal blocks as well.\n\t7. The name field is manadatory for all blocks and cannot be left empty at any time.\n\n### Best Practices\nRecommended practices to make it easier for everyone\n\t1. No attributes should be left empty. It is common that all values are not known during the design phase, but eventuallly all the attributes have to filled in. it is the responsibility of the architect to maintain this.\n\t2. To make the architecture diagrams more readable, it is recommended to have inputs of a block on the left side and the outputs of on the right. Similar to how simulink blokcs behave.\n\t3. It is recommended to have the frame object on all sheets. This would improve readability and make referencing a lot more easier.\n\n### Rules for naming components\n\t1. \n\n### Rules for naming signals\n\t1.\n\n### Rules for naming connectors\n\t1.\n\n\n## Resources/References\n\n1. First picture from: A. Magnusson, L. Laine, and J. Lindberg, \xe2\x80\x9cRethink EE Architecture in Automotive to Facilitate Automation, Connectivity, and Electro Mobility,\xe2\x80\x9d in 2018 IEEE/ACM 40th International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP), 2018, pp. 65\xe2\x80\x9374.\n\n2. [Representing Systems with Models](https://www.sebokwiki.org/wiki/Representing_Systems_with_Models)\n\n3. [Physical Architecture Development](https://www.sebokwiki.org/wiki/Physical_Architecture_Model_Development)\n\n4. [Logical Architecture Development](https://www.sebokwiki.org/wiki/Logical_Architecture_Model_Development)\n\n5. [ISO42010:Systems and Software Engineering - Architecture Description(Also available via KTH Bibliotek)](http://cabibbo.dia.uniroma3.it/asw/altrui/iso-iec-ieee-42010-2011.pdf)\n\n6. [MITOCW Course: Fundamentals of Systems Engineering](https://ocw.mit.edu/courses/aeronautics-and-astronautics/16-842-fundamentals-of-systems-engineering-fall-2015/)\n\n7. [PREEVISION Modelling Layers](https://assets.vector.com/cms/content/products/preevision/docs/PREEvision_doc_poster_layermodel_high_EN.pdf)\n\n8. [Architectural Toolbox Spreadsheet](https://docs.google.com/spreadsheets/d/1PIzP23Clr_O61puY6UsiDqqGI817U3qS0Zpk4OHzGXA/edit?usp=sharing)"